给定一个字符串，每个单词由一个或多个空格分隔，字符串头部和尾部可能也有空格，返回该字符串按照单词翻转，单词间仅有一个空格分割，并去掉首尾空格

eg: source = "   hello  wolrd   "     返回："wolrd hello"    
    source = "   algorithm understand and achieve!  "     返回："achieve! and understand algorithm"
    
    
    public static String reverseStringByWord(String source){
        if(source == null || source.length() == 0) return source;
        
        StringBuffer result = new StringBuffer();
        StringBuffer tempWord = new StringBuffer();
        int len = source.length();  
        
        while(len != 0){
             tempWord.delete(0,tempWord.length());
             while(!Character.isSpaceChar(source.charAt(--len))){
                  tempWord.append(source.charAt(len));
                  if(len == 0){
                      break;
                  }
             }
             
             if(!result.toString().isEmpty()){
                  result.append(" "); 
             }
             char[] tempCharArray = tempWord.toString().toCharArray();
             reverseString(tempCharArray , 0 , tempCharArray.length-1);
             result.append(tempCharArray);
        }
        
        return result.toString().trim();
    }
    
    
辅助函数：reverseString(char[] charArray ,int start ,int end)     翻转字符串
    
    
    
    public static void reverseString(char[] charArray, int start ,int end){
        if(charArray ==null ||charArray.length ==0)  return;
        
        char temp;
        while(start < end){
             temp = charArray[end];
             charArray[start] = charArray[end];
             charArray[end] = temp;
             start++;
             end--;
        }
        
    }
    
    
    
判断一个字符串是否是非严格意义上的回文串，即在只考虑字母和数字，字母不区分大小写的情况下，是否构成回文串，返回布尔结果


eg:source = "A man, a plan, a canal: Panama"       返回：true
   source = "race a car"                           返回：false
   
   
   public static boolean judgeIsPalindRome(String source){
        if(source == null || source.length() ==0)  return true;
        
        int left = 0;
        int right = source.length() -1;
        while(left < right){
        
            if(!Character.isLetterOrDigit(source.charAt(left))){
                left++;
                continue;
            }
            if(!Character.isLetterOrDigit(source.charAt(right))){
                right--;
                continue;
            }
            if(Character.toLowerCase(source.charAt(left)) == Character.toLowerCase(source.charAt(right))){
                left++;
                right--;
            }else{
                return false;
            }
        }
        return true;
   }
    
    
    
 求一个字符串的最长回文字串，并返回
 
 
 eg:source = "abcdzdcab"    返回："cdzdc"
    source = "abdccd"       返回："dccd"
    
    
    
    public static String getMaxLongRalindRomeSubStringByEum(String source){  // 思路一，暴力枚举所有字串，记下最长回文串的起止位置
           if(source == null || source.length() == 0) return source;
           
           String result = new String();
           int start = 0;
           int end = 0;
           int longest = 0;
           
           for(int i=0;i < source.length();i++){
                 for(int j = i+1;j <= source.length();j++){
                    String tempStr = source.substring(i,j);
                    if(isPalindRome(tempStr) && tempStr.length() > longest){
                         start = i;
                         end = j;
                         longest = tempStr.length();
                    }
                 }
           }
           result = source.substring(start,end);
           return result;
    }
    
    
辅助函数：boolean isRalindRome(String source)   判断一字符串是不是回文串

     private static boolean isPalindRome(String source){
        if(source == null || source.length() ==0 ) return true;
        
        for(int i =0 ;i< source.length(); i++){
            if(source.charAt(i) != source.charAt(source.length() -i -1)){
                return false;
            }
        }
        return true;
     }
    
    
    
    
    public static String getMaxLongPalindRomeSubString(String source){
        if(source == null || source.length() == 0) return source;
        
        String result = new String();
        String tempStr = null;
        for(int i=0;i<source.length();i++){
        
            tempStr = getPalindRome(source,i,i);    // 字符串长度是奇数的情况
            if(tempStr != null && tempStr.length() > result.length()){
                result = tempStr;
            }
            
            tempStr = getPalindRome(source,i,i+1);  // 字符串长度是偶数的情况
            if(tempStr != null && tempStr.length() > result.length()){
                result = tempStr;
            }
        }
        
        return result;
    }
    
    
辅助函数  String getPalindRome(String source, int left , int right)

     
     public static String getPalindRome(String source, int left , int right){
         if(source == null || source.length() == 0)  return source;
        
         while(left >= 0 && right < source.length() && source.charAt(left) == source.charAt(right)){
                left--;
                right++;
         }
         return source.substring(left+1,right);
     }
    
    
    
给定一个含有空格的字符串，设计一种算法将字符串中的空格全部替换为"%20"，并返回替换后的字符串

eg: source = "Mr John Smith"   返回：Mr%20John%20Smith
    source = "Ms  Tom "        返回：Ms%20%20Tom%20
    
    
    public static String replaceAllSpace(String source){
        if(source ==null && source.length() ==0) return source;
        
        int n =0;
        for(int i=0;i<source.length();i++){
            if(Character.isSpaceChar(source.charAt(i)))  ++n;
        }
        
        int newLen = source.length() + 2*n;
        char[] charArray = new char[newLen];
        for(int i=source.length() -1;i>=0;i--){
            if(!Character.isSpaceChar(source.charAt(i))){
                charArray[--newLen] = source.charAt(i);
            }else{
                charArray[--newLen] = '0';
                charArray[--newLen] = '2';
                charArray[--newLen] = '%';
            }
        }
        return String.valueOf(charArray);
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
