题目描述：在源字符串source 中查找目标字符串target ，并返回目标字符串首次在源字符串出现的位置，类似于库函数indexOf()功能

eg：  source =  "abhdgf"    target= "hdg"    返回  2              
      source =  "ghdks"    target= "hds"     返回 -1
      
      // 该算法的时间复杂度为 O((n-m)*m)
      public static int getFirstIndex(String source , String target){
              if(source == null && target == null)  return 0;
              if(source == null || source.length() < target.length()) return -1;
              if(target == null)  return 0;
              
              for(int i = 0;i<source.length()-target.length()+1;i++){  // 实际上遍历source，只需要遍历0到n-m+1，当i>n-m+1时，就算source从n-m+1
                  int j = 0;                                           // 开始一直到n 这个总长度是小于target的长度m，必定匹配不成功！
                  for(;j<target.length();j++){
                        if(source.charAt(i+j) != target.charAt(j)){
                            break;
                        }
                  }
                  if(j == target.length()){
                      return i;
                  }
              }
              return -1;
      }
      
      
      
      
判断两个字符串是否互为变位词，变位词指的是两个字符串中相同字符出现的次数相同
      
eg:   str1 = "acdfcacd"    str2 = "fcdccdaa"    返回 true
      str1 = "acdfcacd"    str2 = "aadfdccd"    返回false
      
      
      public static boolean judgeAnagramsByHash(String str1 ,String str2){   // 思路一
            if(str1 == null ||str2 ==null) return false;
            if(str1.length() != str2.length()) return fasle;
            
            int[] indexArray = new int[256];
            for(int i=0;i < str1.length();i++){   // 巧妙应用hashMap词频统计
                  ++indexArray[str1.charAt(i)];
                  --indexArray[str2.charAt(i)];
            }
            
            for(int i=0;i < indexArray.length;i++){
                  if(indexArray[i] !=0){
                        return false;
                  }
            }
            return true;
      }
    
    
    public static boolean judgeAnagramsBySort(String str1 ,String str2){ // 思路二
            if(str1 == null || str2 == null ) return false;
            if(str1.length() != str2.length()) return fasle;
            
            char[] charArray1 = str1.toCharArray();      // 灵活运用将字符串先排序，再比较
            char[] charArray2 = str2.toCharArray();
            Arrays.sort(charArray1);
            Arrays.sort(charArray2);
            if(String.valueOf(charArray1).compareTo(String.valueOf(charArray2)) == 0){
                  return true;
            }else return false;
            
    }
      
    
判断两个字符串str1是否包含str2中的所有字符，注：str1和str2这两个字符串中的字符都是大写的英文字符
      
eg:   str1 = "ANHDM"    str2 = "MNA"    返回 true
      str1 = "ANHDM"    str2 = "DKM"    返回false
      
      
      public static boolean judgeContainByHash(String str1 , String str2){
            if(str1 ==null || str2 ==null) return false;
            if(str1.length() <str2.length()) return false;
            
            int[] counter = new counter[26];
            for(int i=0;i<str1.length();i++){
                  ++counter[str1.charAt(i)-'A'];
            }
            for(int i=0;i<str2.length();i++){
                  --counter[str2.charAt(i)-'A'];
                  if(counter[str2.charAt(i)-'A'] <0){
                        return false
                  }
            }
            return true;
      }
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
